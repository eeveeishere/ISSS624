---
title: "Take home Exercise 1"
editor: visual
execute: 
  warning: false
  message: false
format: html
---

## 

# Take-home Exercise 1: Geospatial Analytics for Social Good

## Setting the Scene

Water is an important resource to mankind. Clean and accessible water is critical to human health. It provides a healthy environment, a sustainable economy, reduces poverty and ensures peace and security. Yet over 40% of the global population does not have access to sufficient clean water. By 2025, 1.8 billion people will be living in countries or regions with absolute water scarcity, according to UN-Water. The lack of water poses a major threat to several sectors, including food security. Agriculture uses about 70% of the world\'s accessible freshwater.

Developing countries are most affected by water shortages and poor water quality. Up to 80% of illnesses in the developing world are linked to inadequate water and sanitation. Despite technological advancement, providing clean water to the rural community is still a major development issues in many countries globally, especially countries in the Africa continent.

To address the issue of providing clean and sustainable water supply to the rural community, a global [Water Point Data Exchange (WPdx)](https://www.waterpointdata.org/about/) project has been initiated. The main aim of this initiative is to collect water point related data from rural areas at the water point or small water scheme level and share the data via WPdx Data Repository, a cloud-based data library. What is so special of this project is that data are collected based on [WPDx Data Standard](https://www.waterpointdata.org/wp-content/uploads/2021/04/WPDx_Data_Standard.pdf).

## Getting Started

In the code chunk below, `p_load()` of *pacman* package is used to install and load the following R packages into R environment:

-   sf,

-   tidyverse,

-   tmap,

-   spdep, and

-   funModeling will be used for rapid Exploratory Data Analysis

```{r}
pacman::p_load(sf, tidyverse, tmap, spdep, funModeling)
```

In this in-class data, two geospatial data sets will be used, they are:

geo_export

nga_admbnda_adm2_osgod_20190417

## Importing water point geospatial data

First, we are going to import the water point geospatial data by using the code chunk below.

```{r}

wp <- st_read(dsn = "geodata",
              layer = "geo_export",
              crs = 4326)%>%
  filter(clean_coun == "Nigeria")
```

next, write_rds() of readr package is used to save the extracted sf data table into an output file in rds data format. The output file is called wp_nga.rds and is is save in geodata subfoulder.

```{r}
write_rds(wp, "geodata/wp_nga.rds")
```

Next, we are going to import the LGA boundary data into R environment by using the code chunk below.

```{r}
nga <- st_read(dsn = "geodata",
               layer = "nga_admbnda_adm2_osgof_20190417",
               crs = 4326)
```

## Data Wrangling

**Recoding NA values into string**

In the code chunk below, replace_na() is used to recode all the NA values in status_cle field into unknow,

```{r}
wp_nga <- read_rds("geodata/wp_nga.rds")%>%
  mutate(status_cle = replace_na(status_cle, "Unknown"))
```

## EDA

In the code chunk below, freq() of funModeling package is used to display the distribution of status_cle field in wp_nga.

```{r}
freq(data = wp_nga,
     input = 'status_cle')
```

Extracting funtional water point

using classes in status_cle field.

```{r}
wpt_functional <- wp_nga %>%
  filter(status_cle %in%
           c("Functional", 
             "Functional but not in use",
             "Functional but needs repair"))
```

```{r}
freq(data=wpt_functional, 
     input = 'status_cle')
```

So all functional data will be called as wpt_functional.

Similarly for non-functional water point.

```{r}
wpt_nonfunctional <- wp_nga %>%
  filter(status_cle %in%
           c("Abandoned/Decommissioned", 
             "Abandoned",
             "Non-Functional",
             "Non functional due to dry season",
             "Non-Functional due to dry season"))
```

Extracting water point with Unknown class.

Using filter() of dplyr to select water points with unknown status.

```{r}
wpt_unknown <- wp_nga %>%
  filter(status_cle == "Unknown")
```

## Performing point in polygon count

```{r}
nga_wp <- nga %>% 
  mutate(`total wpt` = lengths(
    st_intersects(nga, wp_nga))) %>%
  mutate(`wpt functional` = lengths(
    st_intersects(nga, wpt_functional))) %>%
  mutate(`wpt non-functional` = lengths(
    st_intersects(nga, wpt_nonfunctional))) %>%
  mutate(`wpt unknown` = lengths(
    st_intersects(nga, wpt_unknown)))
```

Saving the Analytical Data Table

```{r}
nga_wp <- nga_wp %>%
  mutate(pct_functional = `wpt functional`/`total wpt`) %>%
  mutate(`pct_non-functional` = `wpt non-functional`/`total wpt`) %>%
  select(3:4, 9:10, 18:23)
```

Now I got the tidy sf data table and we will save the sf data table in rds format.

```{r}
write_rds(nga_wp, "geodata/nga_wp.rds")
```

## Visualising the spatial distribution of water points

```{r}

nga_wp <- read_rds("geodata/nga_wp.rds")
total <- qtm(nga_wp, "total wpt") +
  tm_layout(legend.height = 0.25, legend.width = 0.35)
wp_functional <- qtm(nga_wp, "wpt functional") +
   tm_layout(legend.height = 0.25, legend.width = 0.35)
wp_nonfunctional <- qtm(nga_wp, "wpt non-functional") +
   tm_layout(legend.height = 0.25, legend.width = 0.35)
unknown <- qtm(nga_wp, "wpt unknown") +
   tm_layout(legend.height = 0.25, legend.width = 0.35)


tmap_arrange(total, wp_functional, wp_nonfunctional, unknown, asp=1, ncol=2 )


```

Computing (Queen) contiguity based neighbours

```{r}
wm_q <- poly2nb(nga_wp, queen = TRUE)
summary(wm_q)
```

The summary report shows that there are 774 region in Nigeria. Region 86 has no neighbour, 138 and 506 has only 1 neighbour and region 508 has the most number of neighbour 14.

```{r}
wm_q[[1]]
```

```{r}
nga_wp$ADM2_EN[1]
```

```{r}
nb1 <- wm_q[[1]]
nb1 <- nga_wp$ADM2_EN[nb1]
nb1
```

```{r}
set.ZeroPolicyOption(TRUE)
```

```{r}
rswm_q <- nb2listw(wm_q,
                   style = "W",
                   zero.policy = TRUE)
rswm_q
```

Maron's \| test

```{r}
moran.test(nga_wp$`wpt non-functional`,
           listw = rswm_q,
           zero.policy = TRUE,
           na.action = na.omit)
```

Computing Monte Carlo Moran's \|

```{r}
set.seed(1234)
bperm = moran.mc(nga_wp$`wpt non-functional`,
                 listw = rswm_q,
                 nsim = 999,
                 zero.policy = TRUE,
                 na.action = na.omit)
bperm
```

Visualising Monte Carlo Moran's \|

```{r}
mean(bperm$res[1:999])
```

```{r}
var(bperm$res[1:999])
```

```{r}
summary(bperm$res[1:999])
```

```{r}
ggplot(as.data.frame(bperm[7]),aes(x=res)) +
  geom_density(fill = "lightgrey") +
  geom_vline(aes(xintercept=0.43393),
             color = "red", linetype = "dashed", size = 1) +
  labs(title = "Monte Carlo simulation of Moran's |",
       x = "Test statistic",
       y = "Density")
```

Compute Spatial Correlogram

```{r}
MI_corr <- sp.correlogram(wm_q,
                          nga_wp$`wpt non-functional`,
                          order = 6,
                          method = "I",
                          style = "W")
plot(MI_corr)
```

```{r}
print(MI_corr)
```

Compute local Moran's \|

```{r}
fips <- order(nga_wp$ADM2_EN)
localMI <- localmoran(nga_wp$`wpt non-functional`,rswm_q)
head(localMI)
```

```{r}
nga_wp.localMI <- cbind(nga_wp,localMI) %>%
  rename(Pr.Ii = Pr.z....E.Ii..)
```

Mapping local moran's \| values

```{r}
tm_shape(nga_wp.localMI) +
  tm_fill(col = "Ii",
          style = "pretty",
          palette = "RdBu",
          title = "local moran statistics") +
  tm_borders(alpha = 0.5) +
  tm_layout(legend.width = 0.35,
            legend.height = 0.25)
```

Mapping local Moran's \| p-values

```{r}
tm_shape(nga_wp.localMI) +
  tm_fill(col = "Pr.Ii",
          breaks = c(-Inf,0.001, 0.01, 0.05, 0.1,Inf),
          palette = "-Blues",
          title = "local Moran's I p-values") +
  tm_borders(alpha = 0.5) +
  tm_layout(legend.width = 0.35,
            legend.height = 0.25)
```

Mapping both local Moran's \| values and p-values

```{r}
localMI.map <- tm_shape(nga_wp.localMI) +
  tm_fill(col = "Ii", 
          style = "pretty", 
          title = "local moran statistics") +
  tm_borders(alpha = 0.5)

pvalue.map <- tm_shape(nga_wp.localMI) +
  tm_fill(col = "Pr.Ii", 
          breaks=c(-Inf, 0.001, 0.01, 0.05, 0.1, Inf),
          palette="-Blues", 
          title = "local Moran's I p-values") +
  tm_borders(alpha = 0.5)

tmap_arrange(localMI.map, pvalue.map, ncol=2)
```

Creating a Lisa cluster Map
